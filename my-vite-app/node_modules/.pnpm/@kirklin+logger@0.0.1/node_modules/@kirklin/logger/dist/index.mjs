var Level = /* @__PURE__ */ ((Level2) => {
  Level2[Level2["Trace"] = 0] = "Trace";
  Level2[Level2["Debug"] = 1] = "Debug";
  Level2[Level2["Info"] = 2] = "Info";
  Level2[Level2["Warn"] = 3] = "Warn";
  Level2[Level2["Error"] = 4] = "Error";
  return Level2;
})(Level || {});

function doLog(level, ...args) {
  switch (level) {
    case Level.Trace:
      return console.trace(...args);
    case Level.Debug:
      return console.debug(...args);
    case Level.Info:
      return console.info(...args);
    case Level.Warn:
      return console.warn(...args);
    case Level.Error:
      return console.error(...args);
  }
}

class Field {
  constructor(identifier, value) {
    this.identifier = identifier;
    this.value = value;
  }
  toJSON() {
    return {
      identifier: this.identifier,
      value: this.value
    };
  }
}

class Formatter {
  constructor(formatType = "%s", useColors = true) {
    this.formatType = formatType;
    this.useColors = useColors;
    this.minimumTagWidth = 5;
    this.message = { format: "", args: [], fields: [] };
  }
  /**
   * Add tag
   */
  tag(name, color) {
    let spaced = name;
    for (let i = name.length; i < this.minimumTagWidth; ++i) {
      spaced += " ";
    }
    this.push(`${spaced} `, color);
  }
  push(arg, color, weight) {
    if (Array.isArray(arg) && arg.every((a) => a instanceof Field)) {
      this.message.fields.push(...arg);
      return;
    }
    if (this.useColors && (color || weight)) {
      this.message.format += `${this.formatType}${this.getType(arg)}${this.formatType}`;
      this.message.args.push(this.style(color, weight), arg, this.reset());
    } else {
      this.message.format += `${this.getType(arg)}`;
      this.message.args.push(arg);
    }
  }
  /**
   * Write log entry
   */
  write(level) {
    const message = this.flush();
    this.doWrite(level, message);
  }
  /**
   * Reset state and return message
   */
  flush() {
    const message = this.message;
    this.message = { format: "", args: [], fields: [] };
    return message;
  }
  /**
   * Return format string based on argument type
   */
  getType(arg) {
    switch (typeof arg) {
      case "object":
        return "%o";
      case "number":
        return "%d";
      default:
        return "%s";
    }
  }
}

class BrowserFormatter extends Formatter {
  constructor() {
    super("%c");
  }
  style(color, weight) {
    return (color ? `color: ${color};` : "") + (weight ? `font-weight: ${weight};` : "");
  }
  reset() {
    return this.style("inherit", "normal");
  }
  doWrite(level, message) {
    console.groupCollapsed(message.format, ...message.args);
    message.fields.forEach((field) => {
      this.push(field.identifier, "#3794ff", "bold");
      if (typeof field.value !== "undefined" && field.value.constructor && field.value.constructor.name) {
        this.push(` (${field.value.constructor.name})`);
      }
      this.push(": ");
      this.push(field.value);
      const m = this.flush();
      doLog(level, m.format, ...m.args);
    });
    console.groupEnd();
  }
}

class ServerFormatter extends Formatter {
  constructor() {
    super("%s", !!process.stdout.isTTY);
  }
  style(color, weight) {
    return (weight === "bold" ? "\x1B[1m" : "") + (color ? this.hex(color) : "");
  }
  reset() {
    return "\x1B[0m";
  }
  hex(hex) {
    const [r, g, b] = this.hexToRgb(hex);
    return `\x1B[38;2;${r};${g};${b}m`;
  }
  hexToRgb(hex) {
    const integer = parseInt(hex.substring(1), 16);
    return [integer >> 16 & 255, integer >> 8 & 255, integer & 255];
  }
  doWrite(level, message) {
    if (message.fields.length === 0) {
      return doLog(level, `[%s] ${message.format}`, new Date().toISOString(), ...message.args);
    }
    const obj = {};
    message.fields.forEach((field) => obj[field.identifier] = field.value);
    doLog(
      level,
      `[%s] ${message.format} %s%s%s`,
      new Date().toISOString(),
      ...message.args,
      this.style("#8c8c8c"),
      JSON.stringify(obj),
      this.reset()
    );
  }
}

class Time {
  constructor(expected, ms) {
    this.expected = expected;
    this.ms = ms;
  }
}

class Logger {
  constructor(_formatter, name, defaultFields, extenders = []) {
    this._formatter = _formatter;
    this.name = name;
    this.defaultFields = defaultFields;
    this.extenders = extenders;
    this.level = Level.Info;
    this.muted = false;
    if (name) {
      this.nameColor = this.hashStringToColor(name);
    }
    if (typeof process !== "undefined" && typeof process.env !== "undefined") {
      switch (process.env.LOG_LEVEL) {
        case "trace":
          this.level = Level.Trace;
          break;
        case "debug":
          this.level = Level.Debug;
          break;
        case "info":
          this.level = Level.Info;
          break;
        case "warn":
          this.level = Level.Warn;
          break;
        case "error":
          this.level = Level.Error;
          break;
      }
    }
  }
  set formatter(formatter) {
    this._formatter = formatter;
  }
  get formatter() {
    return this._formatter;
  }
  /**
   * Suppresses all output
   */
  mute() {
    this.muted = true;
  }
  extend(extender) {
    this.extenders.push(extender);
  }
  info(message, ...fields) {
    this.handle({
      message,
      fields,
      tagColor: "#66ccff",
      level: Level.Info
    });
  }
  warn(message, ...fields) {
    this.handle({
      message,
      fields,
      tagColor: "#ffae00",
      level: Level.Warn
    });
  }
  trace(message, ...fields) {
    this.handle({
      message,
      fields,
      tagColor: "#9e9e9e",
      level: Level.Trace
    });
  }
  debug(message, ...fields) {
    this.handle({
      message,
      fields,
      tagColor: "#ffb8da",
      level: Level.Debug
    });
  }
  error(message, ...fields) {
    this.handle({
      message,
      fields,
      tagColor: "#ff0000",
      level: Level.Error
    });
  }
  /**
   * Returns a sub-logger with a name.
   * Each name is deterministically generated a color.
   */
  named(name, ...fields) {
    const l = new Logger(this._formatter, name, fields, this.extenders);
    if (this.muted) {
      l.mute();
    }
    return l;
  }
  handle(message) {
    if (this.level > message.level || this.muted) {
      return;
    }
    let passedFields = message.fields || [];
    if (typeof message.message === "function") {
      const values = message.message();
      message.message = values.shift();
      passedFields = values;
    }
    const fields = this.defaultFields ? passedFields.filter((f) => !!f).concat(this.defaultFields) : passedFields.filter((f) => !!f);
    const now = Date.now();
    let times = [];
    const hasFields = fields && fields.length > 0;
    if (hasFields) {
      times = fields.filter((f) => f.value instanceof Time);
      this._formatter.push(fields);
    }
    this._formatter.tag(Level[message.level].toLowerCase(), message.tagColor);
    if (this.name && this.nameColor) {
      this._formatter.tag(this.name, this.nameColor);
    }
    this._formatter.push(message.message);
    if (times.length > 0) {
      times.forEach((time) => {
        const diff = now - time.value.ms;
        const expPer = diff / time.value.expected;
        const min = 125 * (1 - expPer);
        const max = 125 + min;
        const green = expPer < 1 ? max : min;
        const red = expPer >= 1 ? max : min;
        this._formatter.push(` ${time.identifier}=`, "#3390ff");
        this._formatter.push(
          `${diff}ms`,
          this.rgbToHex(red > 0 ? red : 0, green > 0 ? green : 0, 0)
        );
      });
    }
    this._formatter.write(message.level);
    this.extenders.forEach((extender) => {
      extender({
        section: this.name,
        ...message
      });
    });
  }
  /**
   * Hashes a string.
   */
  djb2(str) {
    let hash = 5381;
    for (let i = 0; i < str.length; i++) {
      hash = (hash << 5) + hash + str.charCodeAt(i);
    }
    return hash;
  }
  rgbToHex(r, g, b) {
    const integer = ((Math.round(r) & 255) << 16) + ((Math.round(g) & 255) << 8) + (Math.round(b) & 255);
    const str = integer.toString(16);
    return `#${"000000".substring(str.length)}${str}`;
  }
  /**
   * Generates a deterministic color from a string using hashing.
   */
  hashStringToColor(str) {
    const hash = this.djb2(str);
    return this.rgbToHex((hash & 16711680) >> 16, (hash & 65280) >> 8, hash & 255);
  }
}
const logger = new Logger(
  typeof process === "undefined" || typeof process.stdout === "undefined" ? new BrowserFormatter() : new ServerFormatter()
);

export { Logger, logger };
